/***************************************************************************
 *                               CREDITS
 *                         -------------------
 *                         : (C) 2004-2009 Luke Tomasello (AKA Adam Ant)
 *                         :   and the Angel Island Software Team
 *                         :   luke@tomasello.com
 *                         :   Official Documentation:
 *                         :   www.game-master.net, wiki.game-master.net
 *                         :   Official Source Code (SVN Repository):
 *                         :   http://game-master.net:8050/svn/angelisland
 *                         : 
 *                         : (C) May 1, 2002 The RunUO Software Team
 *                         :   info@runuo.com
 *
 *   Give credit where credit is due!
 *   Even though this is 'free software', you are encouraged to give
 *    credit to the individuals that spent many hundreds of hours
 *    developing this software.
 *   Many of the ideas you will find in this Angel Island version of 
 *   Ultima Online are unique and one-of-a-kind in the gaming industry! 
 *
 ***************************************************************************/

/***************************************************************************
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 ***************************************************************************/

/* Scripts/Engines/Spawner/Spawner.cs
 * Changelog:
 *	5/12/09, Adam
 *		Check for value==null when setting the LootPack
 *	01/14/09, plasma
 *		Added OnAfterMobileSpawn( Mobile )
 *	10/28/08, plasma
 *		Virtualised Spawn()
 *	10/17/08, Adam
 *		In OnDelete make sure to delete all templates!
 *	10/16/08, Adam
 *		- Add a LootPack Item (or container item) that specifies special loot for creatures generated by this spawner. BaseCreature takes care of the actual interpretation of this value.
 *      - Make sure the current lootpack is deleted before a new one is assigned.
 *      - Make sure to remove the loot from the parent container.
 *	4/20/08, Adam
 *		Make GetSpawnPosition() a public function
 *	11/1/07, Adam
 *		When using target mode to setup a Template Item or Mobile, set/clear the SpawnerTempMob or SpawnerTempItem for the template
 *		We need to clear it for the old Template so that it will decay as per usual, and set it for the new one so that it does not 
 *		decay. 
 *		Caution: Don't use anything spawned by a spawner (still on the spawner list) as a template as the spawner will delete it
 *		during a defrag.
 *	8/28/07, Adam
 *		Add a 10% chance to ,ake the spawned creature a Paragon.
 *		The actual decision is in BaseCreature, the spawner only creates the chance.
 *  3/21/07, Adam (removed)
 *      Add DynamicLootTypes for dynamic loot specification.
 *  3/17/07, Adam
 *      Split spawn into a Create function and a Move to world portion.
 *      This is so we can have a public Factory method to create Template Mobiles and Items.
 *  2/26/07, Adam
 *      Make sure to call m_Timer.Flush() to remove any queued ticks.
 *      This is important when setting NextSpawn and there is already a queued tick.
 *  10/19/06, Kit
 *		Made template mobs spawner property be set to spawner they are on.
 *	10/18/06, Adam
 *		- Remove notion of 'Fixed' non-decaying objects
 *		- Refresh() items still on a spawner before decaying (called by ItemDecay in Heartbeat)
 *	9/15/06, Adam
 *		Add function to create a template object only if the Type of the existing template
 *			object has changed. The prevents complex templates from being lost when someone
 *			simply hits 'OK' on the Spawner gump
 *	9/3/06, Adam
 *		Add function to get the Creature List
 *  8/16/06, Kit
 *		Made static copy of mobs copy layers and propertys of those layers to new destination mob.
 *  7/02/06, Kit
 *		Added, property DynamicCopy, if enabled call InitOutfit/InitBody routines of mob.
 *		Added set NameHue to -1(use notority) for vendors spawned with invunerability turned off.
 *		Fixed bug with namehue being set on all spawners.
 *		Added call to InitOutfit() for normal template spawns to prevent cross dressing.
 *	6/30/06, Adam
 *		- remove evil code nulling templates on every spawn if Enable is not set
 *		- Have TemplateEnable invoke appropriate Template Creation / Destruction code
 *		- Propagate Lifespan for Mobiles and LastMove for items (manages decay/cleanup)
 *		- move template creation/management into Spawner class.
 *		- make sure template is only created on the first object specified.
 *		- make TemplateEnable readable by GMs, but writable by Seers
 *  06/27/06, Kit
 *		Added templated ability to spawners, full range of props setting for spawner entry.
 *		Set via TemplateMobile -> view props, or TemplateItem -> view props, packed out old data.
 *  06/27/06, Kit
 *		Added new property MobVendorInvunerable, for setting invunerability on vendors.
 *	6/6/06, Adam
 *		Rename Nav --> m_NavDest to follow normal member naming conventions.
 *	1/9/06, Adam
 *		Change FreezeDecay to AccessLevel.Administrator - used for daily rares
 *	12/20/05, Adam
 *		Add many more attributes for defining dynamic creatures.
 *	12/19/05, Adam
 *		Add logging to the Name and Hue attributes.
 *	12/18/05, Adam
 *		Add the attributes Name and Hue to be applied to the spawned Object.
 *		These are Seer access attributes.
 *	12/16/05, Adam
 *		Warn if we're spawning stuff in a house.
 *		This is a problem becuse the item will be orphaned by the spawer
 *		which can lead to excessive item generation.
 *  12/05/05, Kit
 *		Spawner now calls Think() for creature if creature has a navdestination set.
 *  12/01/05, Kit
 *		Added Serilization for NavDestination
 *  11/29/05 Kit
 *		Added NavDestination property for setting default NavPoint.
 *  11/22/05 TK
 *		Correction MobileDirection to be a separate value from spawner's Item.Direction
 *  11/21/05 Taran Kain
 *      Added MobileDirection property, just a redirect to Item.Direction
 *	3/9/05, Adam
 *		In Defrag() we now check to see if the spawned item is in a HouseRegion.
 *		items in a HouseRegion are assumed to be 'freed' from the spawner and may therefore
 *		be removed from the spawners list of managed items.
 *		We needed this new check because putting an item in your house leaves the parent null which prevents 
 *		the 'fixed' item from decaying and a new item from being spawned. (See previous change)
 *	02/28/05, Adam
 *		1. Add new FreezeDecay property to freeze the decay on spawned items.
 *		2. When someone picks something up, parent is set to non-null. When this happens
 *			We can clear the 'Fixed' flag (item.Fixed = false).
 *		Detailed explanation: 
 *			Items are removed from the spawners list of spawned items during the Defrag() run. 
 *			This Defrag() run is roughly the frequency of the spawner. In the case of daily rares, 
 *			this respawn rate can be days long.
 *			Because spawned rares must necessarily sit on the ground for days and not decay, 
 *			they have a special 'fixed' attribute that prevents them from decaying.
 *			When a player gets a rare home, it will still be fixed until the spawner next runs and 
 *			defrags. When this happens, the 'fixed' attribute will be cleared, and the item will 
 *			decay as usual.
 *	02/28/05, erlein
 *		Now also logs addition and deletion of spawners.
 *	02/27/05, erlein
 *		Added logging of HomeRange and Count property changes.
 *		Now logs all changes to these in /logs/spawnerchange.log
 *	12/29/04, Pix
 *		Now spawned creatures contain the location of the spawner.
 *  6/5/04, Pix
 *		Merged in 1.0RC0 code.
 */

using System;
using System.IO;
using System.Collections;
using Server;
using Server.Items;
using Server.Regions;
using Server.Engines;
using Server.Scripts.Commands;
using System.Reflection;

namespace Server.Mobiles
{
	public class Spawner : Item
	{
		public enum BOOL 
		{
			bDefault = -1,
			bTrue = 1,
			bFalse = 0
		};
	
		private int m_Team;
		private int m_HomeRange;
		private int m_Count;
		private TimeSpan m_MinDelay;
		private TimeSpan m_MaxDelay;
		private ArrayList m_CreaturesName;
		private ArrayList m_Creatures;
		private DateTime m_End;
		private InternalTimer m_Timer;
		private bool m_Running;
		private bool m_Group;
		private bool m_TemplateEnabled;
		private bool m_DynamicCopy;
		private WayPoint m_WayPoint;
		private Direction m_MobDirection;
		private NavDestinations m_NavDest;
		private BOOL m_MobVendorInvul = BOOL.bDefault;
		private Mobile m_TemplateMobile;
		private Item m_TemplateItem;
		private Item m_LootPack;

		[CommandProperty( AccessLevel.GameMaster, AccessLevel.Seer )]
		public bool TemplateEnabled
		{
			get
			{
				return m_TemplateEnabled;
			}
			set
			{
				if ( value )
					InitTemplate();
				else
					DestrtoyTemplate();
				
				InvalidateProperties(); 
			}
		}

		[CommandProperty( AccessLevel.GameMaster, AccessLevel.Seer )]
		public bool DynamicCopy
		{
			get
			{
				return m_DynamicCopy;
			}
			set
			{
				m_DynamicCopy = value;
				InvalidateProperties();
			}
		}

		private void InitTemplate()
		{
			if (m_TemplateEnabled == true)
				return;

			m_TemplateEnabled = true;

			if (m_CreaturesName.Count > 0)
			{
				Type type = SpawnerType.GetType( (string)m_CreaturesName[0] );
				CreateTemplate(this, type);
			}
		}
		
		private void DestrtoyTemplate()
		{	
			if (m_TemplateEnabled == false)
				return;

			m_TemplateEnabled = false;

			// cleanup old templates
			if (TemplateMobile != null)
				TemplateMobile.Delete();
			TemplateMobile = null;

			if (TemplateItem != null)
				TemplateItem.Delete();
			TemplateItem = null;

		}
	
		//hold object for templated spawner use.
		[CommandProperty( AccessLevel.Seer )]
		public Mobile TemplateMobile
		{
			get{ return m_TemplateMobile;}
			// if you are using target mode, this will clear the 'Template' field on the old one and set it on the new
			set
			{	// don't use spawner mobiles as templates because the spawner will delete the template on defrag
				if (m_TemplateMobile != null && m_TemplateMobile.Deleted == false)
					m_TemplateMobile.SpawnerTempMob = false;	// unset the old

				m_TemplateMobile = value;

				if (m_TemplateMobile != null && m_TemplateMobile.Deleted == false)
					m_TemplateMobile.SpawnerTempMob = true;		// reset the new
			}
		}

		//hold object for templated spawner use.
		[CommandProperty(AccessLevel.GameMaster)]
		public Item LootPack
		{
			get { return m_LootPack; }
			set 
            {   // delete the old one
                if (m_LootPack != null && m_LootPack.Deleted == false)
                    m_LootPack.Delete();
                
				// remove from current container
                if (value != null && value.Parent != null && value.Parent is Container)
                    (value.Parent as Container).RemoveItem(value);
                
				// assign
                m_LootPack = value;
            
				// move to int item storage
                if (m_LootPack != null && m_LootPack.Deleted == false)
                    m_LootPack.MoveItemToIntStorage();
            }
		}

		//hold object for templated spawner use.
		[CommandProperty( AccessLevel.Seer )]
		public Item TemplateItem
		{
			get{ return m_TemplateItem;}
			// if you are using target mode, this will clear the 'Template' field on the old one and set it on the new
			set
			{
				// don't use spawner items as templates because the spawner will delete the template on defrag
				if (m_TemplateItem != null && m_TemplateItem.Deleted == false)
					m_TemplateItem.SpawnerTempItem = false;		// unset the old

				m_TemplateItem = value;

				if (m_TemplateItem != null && m_TemplateItem.Deleted == false)
					m_TemplateItem.SpawnerTempItem = true;		// reset the new
			}
		}
				
		// Adam: can be used for rares manufacture - must be seer level minimum
		[CommandProperty( AccessLevel.Seer )]
		public BOOL MobVendorInvunerable
		{ 
			get{ return m_MobVendorInvul; } 
			
			set 
			{ 
				m_MobVendorInvul = value; 
			} 
		}

        public bool IsFull{ get{ return ( m_Creatures != null && m_Creatures.Count >= m_Count ); } }

		private Mobile m_LastProps;	// erl: added to hold who last opened props on it
		public Mobile LastProps
		{
			get
			{
            	return m_LastProps;
			}
			set
			{
				if(value is PlayerMobile)
					m_LastProps = value;
			}
		}

		public ArrayList CreaturesName
		{
			get { return m_CreaturesName; }
			set
			{
				m_CreaturesName = value;
				if ( m_CreaturesName.Count < 1 )
					Stop();

				InvalidateProperties();
			}
		}

		public ArrayList Creatures
		{
			get { return m_Creatures; }
		}

		[CommandProperty( AccessLevel.GameMaster )]
		public int Count
		{
			get { return m_Count; }
			set {
				if(m_Count!=value) {
    				// erl: Log the change to Count
					LogChange("Count changed, " +  m_Count + " to " + value);
    			}
				m_Count = value;
				InvalidateProperties();
			}
		}

		[CommandProperty( AccessLevel.GameMaster )]
		public WayPoint WayPoint
		{
			get
			{
				return m_WayPoint;
			}
			set
			{
				m_WayPoint = value;
			}
		}

		[CommandProperty( AccessLevel.GameMaster )]
		public NavDestinations NavPoint
		{
			get
			{
				return m_NavDest;
			}
			set
			{
				m_NavDest = value;
			}
		}

        [CommandProperty(AccessLevel.GameMaster)]
        public Direction MobileDirection
        {
            get
            {
                return m_MobDirection;
            }
            set
            {
                m_MobDirection = value;
            }
        }

		[CommandProperty( AccessLevel.GameMaster )]
		public bool Running
		{
			get { return m_Running; }
			set
			{
				if ( value )
					Start();
				else
					Stop();

				InvalidateProperties();
			}
		}

		[CommandProperty( AccessLevel.GameMaster )]
		public int HomeRange
		{
			get { return m_HomeRange; }
			set {
				if(m_HomeRange!=value) {
					// erl: Log the change to HomeRange
					LogChange("HomeRange changed, " + m_HomeRange + " to " + value);
				}
				m_HomeRange = value;
				InvalidateProperties();
			}
		}

		[CommandProperty( AccessLevel.GameMaster )]
		public int Team
		{
			get { return m_Team; }
			set { m_Team = value; InvalidateProperties(); }
		}

		[CommandProperty( AccessLevel.GameMaster )]
		public TimeSpan MinDelay
		{
			get { return m_MinDelay; }
			set { m_MinDelay = value; InvalidateProperties(); }
		}

		[CommandProperty( AccessLevel.GameMaster )]
		public TimeSpan MaxDelay
		{
			get { return m_MaxDelay; }
			set { m_MaxDelay = value; InvalidateProperties(); }
		}

		[CommandProperty( AccessLevel.GameMaster )]
		public TimeSpan NextSpawn
		{
			get
			{
				if ( m_Running )
					return m_End - DateTime.Now;
				else
					return TimeSpan.FromSeconds( 0 );
			}
			set
			{
				Start();
				DoTimer( value );
			}
		}

		[CommandProperty( AccessLevel.GameMaster )]
		public bool Group
		{
			get { return m_Group; }
			set { m_Group = value; InvalidateProperties(); }
		}

		[Constructable]
		public Spawner( int amount, int minDelay, int maxDelay, int team, int homeRange, string creatureName ) : base( 0x1f13 )
		{
			ArrayList creaturesName = new ArrayList();
			creaturesName.Add( creatureName.ToLower() );
			InitSpawn( amount, TimeSpan.FromMinutes( minDelay ), TimeSpan.FromMinutes( maxDelay ), team, homeRange, creaturesName );
		}

		[Constructable]
		public Spawner( string creatureName ) : base( 0x1f13 )
		{
			ArrayList creaturesName = new ArrayList();
			creaturesName.Add( creatureName.ToLower() );
			InitSpawn( 1, TimeSpan.FromMinutes( 5 ), TimeSpan.FromMinutes( 10 ), 0, 4, creaturesName );
		}

		[Constructable]
		public Spawner() : base( 0x1f13 )
		{
			ArrayList creaturesName = new ArrayList();
			InitSpawn( 1, TimeSpan.FromMinutes( 5 ), TimeSpan.FromMinutes( 10 ), 0, 4, creaturesName );
			
		}

		public Spawner( int amount, TimeSpan minDelay, TimeSpan maxDelay, int team, int homeRange, ArrayList creaturesName ) : base( 0x1f13 )
		{
			InitSpawn( amount, minDelay, maxDelay, team, homeRange, creaturesName );
		}

		public void InitSpawn( int amount, TimeSpan minDelay, TimeSpan maxDelay, int team, int homeRange, ArrayList creaturesName )
		{
		
			Visible = false;
			Movable = false;
			m_Running = true;
			m_Group = false;
			m_MobDirection = Direction.North;
            Name = "Spawner";
			m_MinDelay = minDelay;
			m_MaxDelay = maxDelay;
			m_Count = amount;
			m_Team = team;
			m_HomeRange = homeRange;
			m_CreaturesName = creaturesName;
			m_Creatures = new ArrayList();
			DoTimer( TimeSpan.FromSeconds( 1 ) );
		}
			
		public Spawner( Serial serial ) : base( serial )
		{
		}

		public override void OnDoubleClick( Mobile from )
		{
			if ( from.AccessLevel < AccessLevel.GameMaster )
				return;

			SpawnerGump g = new SpawnerGump( this );
			from.SendGump( g );
		}

		public override void GetProperties( ObjectPropertyList list )
		{
			base.GetProperties( list );

			if ( m_Running )
			{
				list.Add( 1060742 ); // active

				list.Add( 1060656, m_Count.ToString()); // amount to make: ~1_val~
				list.Add( 1061169, m_HomeRange.ToString() ); // range ~1_val~

				list.Add( 1060658, "group\t{0}", m_Group ); // ~1_val~: ~2_val~
				list.Add( 1060659, "team\t{0}", m_Team ); // ~1_val~: ~2_val~
				list.Add( 1060660, "speed\t{0} to {1}", m_MinDelay, m_MaxDelay ); // ~1_val~: ~2_val~

				for ( int i = 0; i < 3 && i < m_CreaturesName.Count; ++i )
					list.Add( 1060661 + i, "{0}\t{1}", m_CreaturesName[i], CountCreatures( (string)m_CreaturesName[i] ) );
			}
			else
			{
				list.Add( 1060743 ); // inactive
			}
		}

		public override void OnSingleClick( Mobile from )
		{
			base.OnSingleClick( from );

			if ( m_Running )
				LabelTo( from, "[Running]" );
			else
				LabelTo( from, "[Off]" );
		}

		public void Start()
		{
			if ( !m_Running )
			{
				if ( m_CreaturesName.Count > 0 )
				{
					m_Running = true;
					DoTimer();
				}
			}
		}

		public void Stop()
		{
			if ( m_Running )
			{
				m_Timer.Stop();
				m_Running = false;
			}
		}

		private bool InHouse(object o)
		{
			if ( o != null )
			{
				IPoint3D ip = o as IPoint3D;
				Item item = o as Item;
				if ( ip != null && item != null )
				{
					ip = item.GetWorldTop();
					Point3D p = new Point3D( ip );
					Region region = Region.Find( p, item.Map );
					if ( region is HouseRegion )
						return true;
				}
			}

			return false;
		}

		// adam: Refresh items so they do not decay
		public void Refresh()
		{
			try 
			{
				for ( int i = 0; i < m_Creatures.Count; ++i )
				{
					object o = m_Creatures[i];
					if ( o is Item )
					{
						Item item = (Item)o;
						if ( item.Deleted == false && item.Parent == null && item.Decays == true )
							item.SetLastMoved();
					}
				}
			}
			catch(Exception exc)
			{
				LogHelper.LogException(exc);
				System.Console.WriteLine("Exception caught in Spawner.Refresh: " + exc.Message);
				System.Console.WriteLine(exc.StackTrace);
			}
		}

		public void Defrag()
		{
			bool removed = false;

			for ( int i = 0; i < m_Creatures.Count; ++i )
			{
				object o = m_Creatures[i];

				if ( o is Item )
				{
					Item item = (Item)o;

					// adam: if a player picks up an item (rare) and gets it home before
					//	defrag() runs, we want to remove it from our list of controled objects
					//	so that a new item will spawn
					if ( item.Deleted || item.Parent != null || InHouse(o) == true )
					{
						m_Creatures.RemoveAt( i );
						--i;
						removed = true;
					}
				}
				else if ( o is Mobile )
				{
					Mobile m = (Mobile)o;

					if ( m.Deleted )
					{
						m_Creatures.RemoveAt( i );
						--i;
						removed = true;
					}
					else if ( m is BaseCreature )
					{
						if ( ((BaseCreature)m).Controlled || ((BaseCreature)m).IsStabled )
						{
							m_Creatures.RemoveAt( i );
							--i;
							removed = true;
						}
					}
				}
				else
				{
					m_Creatures.RemoveAt( i );
					--i;
					removed = true;
				}
			}

			if ( removed )
				InvalidateProperties();
		}

		public void OnTick()
		{
			DoTimer();

			if ( m_Group )
			{
				Defrag();

				if  ( m_Creatures.Count == 0 )
				{
					Respawn();
				}
				else
				{
					return;
				}
			}
			else
			{
				Spawn();
			}
		}
		
		public static void CopyProperties ( Mobile dest, Mobile src ) 
		{ 
			PropertyInfo[] props = src.GetType().GetProperties(); 

			for ( int i = 0; i < props.Length; i++ ) 
			{ 
				try
				{
					if ( props[i].CanRead && props[i].CanWrite )
					{
						props[i].SetValue( dest, props[i].GetValue( src, null ), null ); 
					}
				}
				catch
				{
					Console.WriteLine("Spawner: Unable to copy property {0}", props[i].Name );
				}
			}
		}

		public static void CopyProperties ( Item dest, Item src ) 
		{ 
			PropertyInfo[] props = src.GetType().GetProperties(); 

			for ( int i = 0; i < props.Length; i++ ) 
			{ 
				try
				{
					if ( props[i].CanRead && props[i].CanWrite )
					{
						props[i].SetValue( dest, props[i].GetValue( src, null ), null ); 
					}
				}
				catch
				{
					Console.WriteLine("Spawner: Unable to copy property {0}", props[i].Name );					
				}
			}
		}

		//wipe layers of src mobile, copy identical layers 
		public static void CopyLayers ( Mobile dest, Mobile src ) 
		{ 
			try
			{
				dest.WipeLayers();
				Item[] items = new Item[21];
				items[0] = src.FindItemOnLayer( Layer.Shoes );
				items[1] = src.FindItemOnLayer( Layer.Pants );
				items[2] = src.FindItemOnLayer( Layer.Shirt );
				items[3] = src.FindItemOnLayer( Layer.Helm );
				items[4] = src.FindItemOnLayer( Layer.Gloves );
				items[5] = src.FindItemOnLayer( Layer.Neck );
				items[6] = src.FindItemOnLayer( Layer.Waist );
				items[7] = src.FindItemOnLayer( Layer.InnerTorso );
				items[8] = src.FindItemOnLayer( Layer.MiddleTorso );
				items[9] = src.FindItemOnLayer( Layer.Arms );
				items[10] = src.FindItemOnLayer( Layer.Cloak );
				items[11] = src.FindItemOnLayer( Layer.OuterTorso );
				items[12] = src.FindItemOnLayer( Layer.OuterLegs );
				items[13] = src.FindItemOnLayer( Layer.InnerLegs );
				items[14] = src.FindItemOnLayer( Layer.Bracelet );
				items[15] = src.FindItemOnLayer( Layer.Ring );
				items[16] = src.FindItemOnLayer( Layer.Earrings );
				items[17] = src.FindItemOnLayer( Layer.OneHanded);
				items[18] = src.FindItemOnLayer( Layer.TwoHanded);
				items[19] = src.FindItemOnLayer( Layer.Hair);
				items[20] = src.FindItemOnLayer( Layer.FacialHair);
				for( int i=0; i < items.Length; i++ )
				{
					if( items[i] != null )
					{
						Type temp = items[i].GetType();
						object o = Activator.CreateInstance( temp );
						if(o != null && o is Item)
						{
							Item item = (Item)o;
							CopyProperties(item, items[i]);
							dest.AddItem(item);
						}
						
					}
				}
			}
			catch(Exception exc)
			{
				LogHelper.LogException(exc);
				System.Console.WriteLine("Send to Zen please: ");
				System.Console.WriteLine("Exception caught in Spawner.CopyLayers: " + exc.Message);
				System.Console.WriteLine(exc.StackTrace);
			}

		}

		public static void CreateTemplate(Spawner Spawner, Type type)
		{
			try
			{
				// cleanup old templates
				if (Spawner.TemplateMobile != null)
					Spawner.TemplateMobile.Delete();
				Spawner.TemplateMobile = null;

				if (Spawner.TemplateItem != null)
					Spawner.TemplateItem.Delete();
				Spawner.TemplateItem = null;

				// create a new thingie
				object o = Activator.CreateInstance( type );

				if(o != null && o is BaseCreature)
				{
					Spawner.TemplateMobile = (BaseCreature)o;
					Spawner.TemplateMobile.SpawnerTempMob = true;
					((BaseCreature)Spawner.TemplateMobile).Spawner = Spawner;
				}

				if(o != null && o is Item)
				{
					Spawner.TemplateItem = (Item)o;
					Spawner.TemplateItem.SpawnerTempItem = true; //set are template flag
									
				}	
			}
			catch
			{
				Console.WriteLine("Spawner({0}): Error createing a template based on type", Spawner.Location);
			}
		}

		public void Respawn()
		{
			RemoveCreatures();

			for ( int i = 0; i < m_Count; i++ )
				Spawn();
		}
		
		public virtual void Spawn()
		{
			if ( m_CreaturesName.Count > 0 )
				Spawn( Utility.Random( m_CreaturesName.Count ) );
		}
		
		public void Spawn( string creatureName )
		{
			for ( int i = 0; i < m_CreaturesName.Count; i++ )
			{
				if ( (string)m_CreaturesName[i] == creatureName )
				{
					Spawn( i );
					break;
				}
			}
		}

		protected virtual void OnAfterMobileSpawn(Mobile m)
		{

		}

		// create the template mob/item for the first item only
		public void CheckTemplate()
		{
			if (TemplateEnabled == false)	// not using templates
				return;

			if ( m_Creatures.Count == 0 )			// there are no creatures defines
				return;

			Type type =								// get the type
				SpawnerType.GetType( (string)m_CreaturesName[0] );

			if (type == null)						// funky
				return;

			if ( TemplateMobile != null && TemplateMobile.GetType() == type )
				return;								// already set, don't loose the custom mob!

			if ( TemplateItem != null && TemplateItem.GetType() == type )
				return;								// already set, don't loose the custom item!

			CreateTemplate(this, type);				// okay, create a template for this spawner
		}

		public void Spawn( int index )
		{
			Map map = Map;

			if ( map == null || map == Map.Internal || m_CreaturesName.Count == 0 || index >= m_CreaturesName.Count )
				return;

			Defrag();

			if ( m_Creatures.Count >= m_Count )
				return;

            // create the mobile ir item
            object o = CreateRaw((string)m_CreaturesName[index]);
		
			if ( o != null )
			{
				try
				{
					if (o is Mobile )
					{
						Mobile m = (Mobile)o;
						m_Creatures.Add( m );
						InvalidateProperties();

						Point3D loc = ( m is BaseVendor ? this.Location : GetSpawnPosition(o) );
						OnAfterMobileSpawn(m);	 //plasma: new "event" allows you to make changes to the mob after spawn
						m.MoveToWorld( loc, map );
						
					}
					else if (o is Item )
					{
						Item item = (Item)o;
						m_Creatures.Add( item );
						InvalidateProperties();
						item.MoveToWorld( GetSpawnPosition(o), map );

						// Adam: Warn if we're spawning stuff in a house.
						//	This is a problem becuse the item will be orphaned by the spawer
						//	which can lead to excessive item generation.
						if ( InHouse(item) == true )
						{
							Console.WriteLine("Warning: House spawn: Item({0}, {1}, {2}), Spawner({3}, {4}, {5})", item.Location.X, item.Location.Y, item.Location.Z, this.Location.X, this.Location.Y, this.Location.Z);
						}
					}
				}
				catch
				{
					Console.WriteLine("Warning: Spawner({0}, {1}, {2}) generating object not template compatible", this.Location.X, this.Location.Y, this.Location.Z);
				}
			}
		}

        public object CreateRaw(string name)
        {
            Map map = Map;

            if ( map == null || map == Map.Internal )
                return null;

            // make sure the thing we are asked to create existes in our list 
            //  of stuff to create.
            bool bFound = false;
            for (int i = 0; i < m_CreaturesName.Count; i++)
            {
                if (((string)m_CreaturesName[i]).ToLower() == name.ToLower())
                {
                    bFound = true;
                    break;
                }
            }
            
            if (bFound == false)
                return null;

            Type type = SpawnerType.GetType(name);
            object o = null;

            if (type != null)
            {
                try
                {
                    // if we are using templates. make sure it's created
                    CheckTemplate();

                    o = Activator.CreateInstance(type);

                    if (o != null)
                    {
                        if (o is Mobile)
                        {
                            Mobile m = (Mobile)o;
                            if (m is BaseCreature)
                            {
                                BaseCreature c = (BaseCreature)m;

								if (m_TemplateEnabled) //copy are template props to the spawning mobile
								{
									TimeSpan OldLifespan = c.Lifespan;
									CopyProperties(c, m_TemplateMobile);
									//c.InitOutfit(); //call this to prevent cross dressing

									if (!DynamicCopy)
										CopyLayers(c, m_TemplateMobile);

									if (DynamicCopy)
									{
										//get use a new name/sex/clothing/body layout
										c.InitBody();
										c.InitOutfit();
									}
									c.Lifespan = OldLifespan;
									c.SpawnerTempMob = false; // Flag this as a template
								}

                                c.RangeHome = m_HomeRange;

                                c.CurrentWayPoint = m_WayPoint;

                                c.NavDestination = m_NavDest;

                                if (m_Team > 0)
                                    c.Team = m_Team;

                                c.Home = this.Location;

                                //Pix: give the spawned creature a ref to this spawner
                                c.Spawner = this;

                                //if we have a navdestination as soon as we spawn start on it
                                if (c.NavDestination != NavDestinations.None)
                                    c.AIObject.Think();

                                /////////////////////////////
                                // customize the mob spawned
                                if (c is BaseVendor)
                                {
                                    if (m_MobVendorInvul != BOOL.bDefault)
                                    {
                                        ((BaseVendor)c).IsInvulnerable = m_MobVendorInvul == BOOL.bTrue ? true : false;
                                        c.NameHue = -1; //reset hue back to useing notority
                                    }
                                }

								// it it's not a template mob, it may be a paragon!
								if (m_TemplateEnabled == false)
									if (Utility.RandomChance(10))
										c.MakeParagon();
							}
                        }
                        else if (o is Item)
                        {
                            Item item = (Item)o;

                            if (m_TemplateEnabled)
                            {
                                DateTime OldLastMoved = item.LastMoved;		// used in decay
                                CopyProperties(item, m_TemplateItem);		// copy all props
                                item.LastMoved = OldLastMoved;				// refresh decay
                                item.SpawnerTempItem = false;				// Flag this as a template
                            }
                        }
                    }
                }
                catch
                {
                    Console.WriteLine("Warning: Spawner({0}, {1}, {2}) generating object not template compatible", this.Location.X, this.Location.Y, this.Location.Z);
                }
            }

            return o;
        }

		/*public Point3D GetSpawnPosition(object o)
		{
			CanFitFlags flags = CanFitFlags.requireSurface;
			if (o is Mobile)
			{
				Mobile m = o as Mobile;
				if (m != null && m.CanSwim == true) flags |= CanFitFlags.canSwim;
				if (m != null && m.CantWalk == true) flags |= CanFitFlags.cantWalk;
			}

			if (Map == null)
				return Location;

			// Try 10 times to find a Spawnable location.
			for (int i = 0; i < 10; i++)
			{
				int x = Location.X + (Utility.Random((m_HomeRange * 2) + 1) - m_HomeRange);
				int y = Location.Y + (Utility.Random((m_HomeRange * 2) + 1) - m_HomeRange);
				int z = Map.GetAverageZ(x, y);

				if (Map.CanSpawnMobile(new Point2D(x, y), this.Z, flags))
					return new Point3D(x, y, this.Z);
				if (Map.CanSpawnMobile(new Point2D(x, y), z, flags))
					return new Point3D(x, y, z);
			}

			return this.Location;
		}*/

		public Point3D GetSpawnPosition(object o)
		{
			return GetSpawnPosition(Map, Location, m_HomeRange, false, o);
		}

		public static Point3D GetSpawnPosition(Map map, Point3D location, int homeRange, bool forceZ, object o)
		{
			CanFitFlags flags = CanFitFlags.requireSurface;
			if (o is Mobile)
			{
				Mobile m = o as Mobile;
				if (m != null && m.CanSwim == true) flags |= CanFitFlags.canSwim;
				if (m != null && m.CantWalk == true) flags |= CanFitFlags.cantWalk;
			}

			if (map == null)
				return location;

			// Try 10 times to find a Spawnable location.
			for (int i = 0; i < 10; i++)
			{
				int x = location.X + (Utility.Random((homeRange * 2) + 1) - homeRange);
				int y = location.Y + (Utility.Random((homeRange * 2) + 1) - homeRange);
				int z = map.GetAverageZ(x, y);

				if (map.CanSpawnMobile(new Point2D(x, y), location.Z, flags))
					return new Point3D(x, y, location.Z);
				if (forceZ == false)
					if (map.CanSpawnMobile(new Point2D(x, y), z, flags))
						return new Point3D(x, y, z);
			}

			return location;
		}

		public void DoTimer()
		{
			if ( !m_Running )
				return;

			int minSeconds = (int)m_MinDelay.TotalSeconds;
			int maxSeconds = (int)m_MaxDelay.TotalSeconds;

			TimeSpan delay = TimeSpan.FromSeconds( Utility.RandomMinMax( minSeconds, maxSeconds ) );
			DoTimer( delay );
		}

		public void DoTimer( TimeSpan delay )
		{
			if ( !m_Running )
				return;

			m_End = DateTime.Now + delay;

            if (m_Timer != null)
            {
                m_Timer.Stop();         // stope the timer
                m_Timer.Flush();        // remove any queued ticks
            }

			m_Timer = new InternalTimer( this, delay );
			m_Timer.Start();
		}

		private class InternalTimer : Timer
		{
			private Spawner m_Spawner;

			public InternalTimer( Spawner spawner, TimeSpan delay ) : base( delay )
			{
				if ( spawner.IsFull )
					Priority = TimerPriority.FiveSeconds;
				else
					Priority = TimerPriority.OneSecond;

				m_Spawner = spawner;
			}

			protected override void OnTick()
			{
				if ( m_Spawner != null )
					if ( !m_Spawner.Deleted )
						m_Spawner.OnTick();
			}
		}

		public int CountCreatures( string creatureName )
		{
			Defrag();

			int count = 0;

			for ( int i = 0; i < m_Creatures.Count; ++i )
				if ( Insensitive.Equals( creatureName, m_Creatures[i].GetType().Name ) )
					++count;

			return count;
		}

		public void RemoveCreatures( string creatureName )
		{
			Defrag();

			creatureName = creatureName.ToLower();

			for ( int i = 0; i < m_Creatures.Count; ++i )
			{
				object o = m_Creatures[i];

				if ( Insensitive.Equals( creatureName, o.GetType().Name ) )
				{
					if ( o is Item )
						((Item)o).Delete();
					else if ( o is Mobile )
						((Mobile)o).Delete();
				}
			}

			InvalidateProperties();
		}
		
		public void RemoveCreatures()
		{
			Defrag();

			for ( int i = 0; i < m_Creatures.Count; ++i )
			{
				object o = m_Creatures[i];

				if ( o is Item )
					((Item)o).Delete();
				else if ( o is Mobile )
					((Mobile)o).Delete();
			}

			InvalidateProperties();
		}

        public static double RandomFar() 
        { 
            if (Utility.RandomBool()) 
                return -Math.Sqrt(Utility.RandomDouble()); 
            else
                return Math.Sqrt(Utility.RandomDouble()); 
        
            // if you want a steeper congregation toward the outside, replace Math.Sqrt(...) with Math.Pow(Utility.RandomDouble(), .33);
            // Pow(x, .33) is cube root, .25 is 4th root etc, etc
            // basically the higher the root, the sharper the dropoff toward center will be
        }

		public void BringToHome()
		{
			Defrag();

			for ( int i = 0; i < m_Creatures.Count; ++i )
			{
				object o = m_Creatures[i];

				if ( o is Mobile )
				{
					Mobile m = (Mobile)o;

					m.MoveToWorld( Location, Map );
				}
				else if ( o is Item )
				{
					Item item = (Item)o;

					item.MoveToWorld( Location, Map );
				}
			}
		}

		// erl: for change logging!

		public void LogChange(string changemade)
		{
			if(changemade == "")
				return;
				
			StreamWriter LogFile = new StreamWriter( "logs/spawnerchange.log", true );

			string strAcc = "";

			if(m_LastProps is PlayerMobile)
				strAcc = m_LastProps.Account.ToString();
			else
				strAcc = "SYSTEM";

			LogFile.WriteLine("{0}, {1}, {2}, {3}, {4}, {5}", DateTime.Now, strAcc, this.Location.X, this.Location.Y, this.Location.Z, changemade);
			LogFile.Close();

		}

		public override void OnDelete()
		{
			base.OnDelete();

			// Remove Templates
			if (this.LootPack != null && this.LootPack.Deleted == false)
				this.LootPack.Delete();

			if (TemplateMobile != null && TemplateMobile.Deleted == false)
				TemplateMobile.Delete();

			if (TemplateItem != null && TemplateItem.Deleted == false)
				TemplateItem.Delete();

			// Remove Creatures
			RemoveCreatures();
			if ( m_Timer != null )
				m_Timer.Stop();

			// erl: Log the fact it's been deleted
			LogChange("Spawner deleted");

		}

		public override void Serialize( GenericWriter writer )
		{
			base.Serialize( writer );

			writer.Write( (int) 11); // version
			
			// v11
			writer.Write(m_LootPack);

			// v10
			writer.Write(m_DynamicCopy);
			writer.Write(m_TemplateMobile);
			writer.Write(m_TemplateItem);
						
			writer.Write((bool)m_TemplateEnabled); 

			writer.Write((int)m_MobVendorInvul); // 8

			writer.Write( false );
			writer.Write( 0 );
			writer.Write( 0 );
			writer.Write( 0 );
			writer.Write( 0 );
			writer.Write( 0 );
			writer.Write( 0 );
			writer.Write( 0 );
			writer.Write( "0" );
			writer.Write( 0 );
			writer.Write( (int)m_NavDest);
			writer.Write((int)m_MobDirection);
            writer.Write( false );				// obsolete: m_FreezeDecay
			writer.Write( m_WayPoint );
			writer.Write( m_Group );
			writer.Write( m_MinDelay );
			writer.Write( m_MaxDelay );
			writer.Write( m_Count );
			writer.Write( m_Team );
			writer.Write( m_HomeRange );
			writer.Write( m_Running );
			
			if ( m_Running )
				writer.WriteDeltaTime( m_End );

			writer.Write( m_CreaturesName.Count );

			for ( int i = 0; i < m_CreaturesName.Count; ++i )
				writer.Write( (string)m_CreaturesName[i] );

			writer.Write( m_Creatures.Count );

			for ( int i = 0; i < m_Creatures.Count; ++i )
			{
				object o = m_Creatures[i];

				if ( o is Item )
					writer.Write( (Item)o );
				else if ( o is Mobile )
					writer.Write( (Mobile)o );
				else
					writer.Write( Serial.MinusOne );
			}
		}

		private static WarnTimer m_WarnTimer;

		public override void Deserialize( GenericReader reader )
		{
			base.Deserialize( reader );

			int version = reader.ReadInt();

			switch ( version )
			{
				case 11:
				{
					m_LootPack = reader.ReadItem();
					goto case 10;
				}
				case 10:
				{
					m_DynamicCopy = reader.ReadBool();
					goto case 9;
				}
				case 9:
				{
					m_TemplateMobile = reader.ReadMobile();
					m_TemplateItem = reader.ReadItem();
					m_TemplateEnabled = reader.ReadBool();
					
					goto case 8;
				}
				case 8:
				{
					
					m_MobVendorInvul = (BOOL)reader.ReadInt();
					goto case 7;
				}
				case 7:
				{
					int dummy = 0;
					bool b = reader.ReadBool();
					dummy = reader.ReadInt();
					dummy = reader.ReadInt();
					dummy = reader.ReadInt();
					dummy = reader.ReadInt();
					dummy = reader.ReadInt();
					dummy = reader.ReadInt();
					dummy = reader.ReadInt();
					goto case 6;
				}
				case 6:
				{
					int dummy = 0;
					string s = reader.ReadString();
					dummy = reader.ReadInt();
					goto case 5;
				}
				case 5:
				{
					m_NavDest = (NavDestinations)reader.ReadInt();
					goto case 4;
				}
				case 4:
				{
					m_MobDirection = (Direction)reader.ReadInt();
					goto case 3;
				}
                case 3:
				{	// obsolete: m_FreezeDecay
					bool dmy = reader.ReadBool();
					goto case 2;
				}

				case 2:
				{
					m_WayPoint = reader.ReadItem() as WayPoint;

					goto case 1;
				}

				case 1:
				{
					m_Group = reader.ReadBool();
					
					goto case 0;
				}

				case 0:
				{
					m_MinDelay = reader.ReadTimeSpan();
					m_MaxDelay = reader.ReadTimeSpan();
					m_Count = reader.ReadInt();
					m_Team = reader.ReadInt();
					m_HomeRange = reader.ReadInt();
					m_Running = reader.ReadBool();

					TimeSpan ts = TimeSpan.Zero;

					if ( m_Running )
						ts = reader.ReadDeltaTime() - DateTime.Now;
					
					int size = reader.ReadInt();

					m_CreaturesName = new ArrayList( size );

					for ( int i = 0; i < size; ++i )
					{
						string typeName = reader.ReadString();

						m_CreaturesName.Add( typeName );

						if ( SpawnerType.GetType( typeName ) == null )
						{
							if ( m_WarnTimer == null )
								m_WarnTimer = new WarnTimer();

							m_WarnTimer.Add( Location, Map, typeName );
						}
					}

					int count = reader.ReadInt();

					m_Creatures = new ArrayList( count );

					for ( int i = 0; i < count; ++i )
					{
						IEntity e = World.FindEntity( reader.ReadInt() );

						if ( e != null )
							m_Creatures.Add( e );
					}

					if ( m_Running )
						DoTimer( ts );

					break;
				}
			}
		}

		private class WarnTimer : Timer
		{
			private ArrayList m_List;

			private class WarnEntry
			{
				public Point3D m_Point;
				public Map m_Map;
				public string m_Name;

				public WarnEntry( Point3D p, Map map, string name )
				{
					m_Point = p;
					m_Map = map;
					m_Name = name;
				}
			}

			public WarnTimer() : base( TimeSpan.FromSeconds( 1.0 ) )
			{
				m_List = new ArrayList();
				Start();
			}

			public void Add( Point3D p, Map map, string name )
			{
				m_List.Add( new WarnEntry( p, map, name ) );
			}

			protected override void OnTick()
			{
				try
				{
					Console.WriteLine( "Warning: {0} bad spawns detected, logged: 'badspawn.log'", m_List.Count );

					using ( StreamWriter op = new StreamWriter( "badspawn.log", true ) )
					{
						op.WriteLine( "# Bad spawns : {0}", DateTime.Now );
						op.WriteLine( "# Format: X Y Z F Name" );
						op.WriteLine();

						foreach ( WarnEntry e in m_List )
							op.WriteLine( "{0}\t{1}\t{2}\t{3}\t{4}", e.m_Point.X, e.m_Point.Y, e.m_Point.Z, e.m_Map, e.m_Name );

						op.WriteLine();
						op.WriteLine();
					}
				}
				catch (Exception ex) { EventSink.InvokeLogException(new LogExceptionEventArgs(ex)); }
			}
		}
	}
}


